function fnct_SIM_follow(target_port, target_init_yaw, drone_port, drone_init_yaw)

%% Multicopter Parameters
% load in the parameters for a frame, generated by Copter.m
try
    state_drone = load('Hexsoon','copter');
catch
    run('Copter.m')
    fprintf('Could not find Hexsoon.mat file, running copter.m\n')
    return
end

% Setup environmental conditions
state_drone.environment.density = 1.225; % (kg/m^3)
state_drone.gravity_mss = 9.80665; % (m/s^2)

%% Vehicle Parameters
state_target.max_jerk = 2;       % Maximum Jerk (m/s^3)
state_target.max_acc = 4;      % Maximum Acceleration (m/s^2)

state_target.max_jerk_brk = 1;       % Maximum Jerk (m/s^3)
state_target.max_acc_brk = 1;      % Maximum Acceleration (m/s^2)

state_target.target_vel = 0;       % Initialize Target Velocity (m/s)
state_target.prev_target_vel = 0;       % Initialize Previous Target Velocity (m/s)

state_target.Pv = 1;
state_target.Dv = 0;
state_target.Pa = 2;
state_target.Da = 0;

state_target.min_vel = 5.5555;
state_target.max_vel = 33.3333;

state_target.gravity_mss = state_drone.gravity_mss; % (m/s^2)

%% Simulation Parameters
% Setup the time step size for the Physics model
max_timestep = 1/50;

% define init and time setup functions
init_function_drone = @init_drone;
physics_function_drone = @physics_step_drone;

init_function_target = @init_target;
physics_function_target = @physics_step_target;

% setup connection
double_SITL_connector(state_drone, state_target, ...
                      drone_init_yaw, target_init_yaw, ...
                      init_function_drone, init_function_target, ...
                      physics_function_drone, physics_function_target, ...
                      drone_port, target_port, ...
                      max_timestep);
end

% Simulator model must take and return a structure with the felids: 
% gyro(roll, pitch, yaw) (radians/sec) body frame
% attitude(roll, pitch yaw) (radians)
% accel(north, east, down) (m/s^2) body frame
% velocity(north, east,down) (m/s) earth frame
% position(north, east, down) (m) earth frame 
% the structure can have any other felids required for the physics model

%% Init function for DRONE
function state = init_drone(state, init_yaw)
state.time_s = 0;
for i = 1:numel(state.copter.motors)
    state.copter.motors(i).rpm = 0;
    state.copter.motors(i).current = 0;
end
state.gyro = [0;0;0]; % (rad/sec)
% state.dcm = diag([1,1,1]); % direction cosine matrix
state.dcm = [[ cosd(init_yaw), -sind(init_yaw), 0];
             [ sind(init_yaw),  cosd(init_yaw), 0];
             [              0                0  1]];
state.attitude = [0;0;init_yaw*pi/180]; % (radians) (roll, pitch, yaw)
state.accel = [0;0;0]; % (m/s^2) body frame
state.velocity = [0;0;0]; % (m/s) earth frame
state.position = [0;0;0]; % (m) earth frame
state.bf_velo = [0;0;0]; % (m/s) body frame
end

%% Physics time step for DRONE
function state = physics_step_drone(pwm_in,state)
% Calculate the dropped battery voltage, assume current draw from last step
state.copter.battery.current = sum([state.copter.motors.current]);
state.copter.battery.dropped_voltage = state.copter.battery.voltage - state.copter.battery.resistance * state.copter.battery.current;

% Calculate the torque and thrust, assume RPM is last step value
for i = 1:numel(state.copter.motors)
    motor = state.copter.motors(i);

    % Calculate the throttle
    throttle = (pwm_in(motor.channel) - 1100) / 800;
    throttle = max(throttle,0);
    throttle = min(throttle,1);

    % effective voltage
    voltage = throttle * state.copter.battery.dropped_voltage;

    % Take the RPM from the last step to calculate the new
    % torque and current
    Kt = 1/(motor.electrical.kv * ( (2*pi)/60) );

    % rpm equation rearranged for current
    current = ((motor.electrical.kv * voltage) - motor.rpm) / ((motor.electrical.resistance + motor.esc.resistance) * motor.electrical.kv);
    torque = current * Kt;

    prop_drag = motor.prop.PConst * state.environment.density * (motor.rpm/60)^2 * motor.prop.diameter^5;

    w = motor.rpm * ((2*pi)/60); % convert to rad/sec

    w1 = w + ((torque-prop_drag) / motor.prop.inertia) * state.delta_t;

    rps = w1 * (1/(2*pi));

    % can never have negative rps
    rps = max(rps,0);

    % Calculate the thrust (with fudge factor!)
    thrust = 2.2 * motor.prop.TConst * state.environment.density * rps^2 * motor.prop.diameter^4;

    % calculate resulting moments
    moment_roll = thrust * motor.location(1);
    moment_pitch = thrust * motor.location(2);
    moment_yaw = -torque * motor.direction;

    % Update main structure
    state.copter.motors(i).torque = torque;
    state.copter.motors(i).current = current;
    state.copter.motors(i).rpm = rps * 60;
    state.copter.motors(i).thrust = thrust;
    state.copter.motors(i).moment_roll = moment_roll;
    state.copter.motors(i).moment_pitch = moment_pitch;
    state.copter.motors(i).moment_yaw = moment_yaw;
end

drag = sign(state.bf_velo) .* state.copter.cd .* state.copter.cd_ref_area .* 0.5 .* state.environment.density .* state.bf_velo.^2;

% Calculate the forces about the CG (N,E,D) (body frame)
force = [0;0;-sum([state.copter.motors.thrust])] - drag;

% estimate rotational drag
rotational_drag = 0.2 * sign(state.gyro) .* state.gyro.^2; % estimated to give a reasonable max rotation rate

% Update attitude, moments to rotational acceleration to rotational velocity to attitude
moments = [-sum([state.copter.motors.moment_roll]);sum([state.copter.motors.moment_pitch]);sum([state.copter.motors.moment_yaw])] - rotational_drag;

state = update_dynamics(state,force,moments);

end

%% DRONE dynamics
function state = update_dynamics(state,force,moments)

rot_accel = (moments' / state.copter.inertia)';

state.gyro = state.gyro + rot_accel * state.delta_t;

% Constrain to 2000 deg per second, this is what typical sensors max out at
state.gyro = max(state.gyro,deg2rad(-2000));
state.gyro = min(state.gyro,deg2rad(2000));

% update the dcm and attitude
[state.dcm, state.attitude] = rotate_dcm(state.dcm,state.gyro * state.delta_t);

% body frame accelerations
state.accel = force / state.copter.mass;

% earth frame accelerations (NED)
accel_ef = state.dcm * state.accel;
accel_ef(3) = accel_ef(3) + state.gravity_mss;

% if we're on the ground, then our vertical acceleration is limited
% to zero. This effectively adds the force of the ground on the aircraft
if state.position(3) >= 0 && accel_ef(3) > 0
    accel_ef(3) = 0;
end

% work out acceleration as seen by the accelerometers. It sees the kinematic
% acceleration (ie. real movement), plus gravity
state.accel = state.dcm' * (accel_ef + [0; 0; -state.gravity_mss]);

state.velocity = state.velocity + accel_ef * state.delta_t;
state.position = state.position + state.velocity * state.delta_t;

% make sure we can't go underground (NED so underground is positive)
if state.position(3) >= 0
    state.position(3) = 0;
    state.velocity = [0;0;0];
    state.gyro = [0;0;0];
end

% calculate the body frame velocity for drag calculation
state.bf_velo = state.dcm' * state.velocity;

end

%% Init function for TARGET
function state = init_target(state, init_yaw)
state.time_s = 0;
state.gyro = [0;0;0]; % (rad/sec)
% state.dcm = diag([1,1,1]); % direction cosine matrix
state.dcm = [[ cosd(init_yaw), -sind(init_yaw), 0];
             [ sind(init_yaw),  cosd(init_yaw), 0];
             [              0                0  1]];
state.attitude = [0;0;init_yaw*pi/180]; % (radians) (roll, pitch, yaw)
state.accel = [0;0;0]; % (m/s^2) body frame (seen by accelerometers)
state.accel_dyn = [0;0;0]; % (m/s^2) body frame (obtained from F=ma) DOESNT INCLUDE GRAVITY
state.accel_ef = [0;0;0]; % (m/s^2) earth frame
state.velocity = [0;0;0]; % (m/s) earth frame
state.position = [0;0;0]; % (m) earth frame
state.bf_velo = [0;0;0]; % (m/s) body frame
state.jerk_dyn = [0;0;0]; % (m/s^3) body frame
state.startMove = 0;
end

%% Physics time step for TARGET
function state = physics_step_target(pwm_in,state)

recv_vel_target = (pwm_in(8)-1000)/1000*(state.max_vel-state.min_vel) + state.min_vel;

if recv_vel_target ~= state.target_vel
    state.prev_target_vel = state.target_vel;
    state.target_vel = recv_vel_target;
end


if all(pwm_in(1:4) > 1050)
    state.startMove = 1;
end

rot_accel = zeros([3,1]);

state.gyro = zeros([3,1]);

% Constrain to 2000 deg per second, this is what typical sensors max out at
state.gyro = max(state.gyro,deg2rad(-2000));
state.gyro = min(state.gyro,deg2rad(2000));

% update the dcm and attitude
[state.dcm, state.attitude] = rotate_dcm(state.dcm,state.gyro * state.delta_t);

if state.startMove == 1
    % Velocity control
    vel_error  = state.target_vel - state.bf_velo(1);
    acc_target = state.Pv*vel_error - state.Dv*state.accel_dyn(1);
    acc_target = max([min([acc_target, state.max_acc]), -state.max_acc_brk]);
    
    % Acceleration control
    acc_error = acc_target - state.accel_dyn(1);
    jerk_target = state.Pa*acc_error - state.Da*state.jerk_dyn(1);
    if acc_target >= 0
        jerk_target = min([jerk_target, state.max_jerk]);
    else
        jerk_target = max([jerk_target, -state.max_jerk_brk]);
    end
    
    % Calculate velocity and position
    state.jerk_dyn  = [jerk_target;0;0];
    state.accel_dyn = state.accel_dyn + state.jerk_dyn*state.delta_t;
else
    state.jerk_dyn  = [0;0;0];
    state.accel_dyn = state.accel_dyn + state.jerk_dyn*state.delta_t;
end

% earth frame accelerations (NED)
accel_ef = state.dcm * state.accel_dyn;
accel_ef(3) = accel_ef(3) + state.gravity_mss;

% if we're on the ground, then our vertical acceleration is limited
% to zero. This effectively adds the force of the ground on the aircraft
if state.position(3) >= 0 && accel_ef(3) > 0
    accel_ef(3) = 0;
end

% work out acceleration as seen by the accelerometers. It sees the kinematic
% acceleration (ie. real movement), plus gravity
state.accel = state.dcm' * (accel_ef + [0; 0; -state.gravity_mss]);

state.velocity = state.velocity + accel_ef * state.delta_t;
state.position = state.position + state.velocity * state.delta_t;

% make sure we can't go underground (NED so underground is positive)
if state.position(3) >= 0
    state.position(3) = 0;
    state.velocity(3) = 0;
end

% calculate the body frame velocity for drag calculation
state.bf_velo = state.dcm' * state.velocity;

end




function [dcm, euler] = rotate_dcm(dcm, ang)

% rotate
delta = [dcm(1,2) * ang(3) - dcm(1,3) * ang(2),         dcm(1,3) * ang(1) - dcm(1,1) * ang(3),      dcm(1,1) * ang(2) - dcm(1,2) * ang(1);
         dcm(2,2) * ang(3) - dcm(2,3) * ang(2),         dcm(2,3) * ang(1) - dcm(2,1) * ang(3),      dcm(2,1) * ang(2) - dcm(2,2) * ang(1);
         dcm(3,2) * ang(3) - dcm(3,3) * ang(2),         dcm(3,3) * ang(1) - dcm(3,1) * ang(3),      dcm(3,1) * ang(2) - dcm(3,2) * ang(1)];

dcm = dcm + delta;

% normalise
a = dcm(1,:);
b = dcm(2,:);
error = a * b';
t0 = a - (b *(0.5 * error));
t1 = b - (a *(0.5 * error));
t2 = cross(t0,t1);
dcm(1,:) = t0 * (1/norm(t0));
dcm(2,:) = t1 * (1/norm(t1));
dcm(3,:) = t2 * (1/norm(t2));

% calculate euler angles
euler = [atan2(dcm(3,2),dcm(3,3)); -asin(dcm(3,1)); atan2(dcm(2,1),dcm(1,1))]; 

end


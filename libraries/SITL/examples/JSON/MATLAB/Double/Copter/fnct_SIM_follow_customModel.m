function fnct_SIM_follow_customModel(target_port, target_init_yaw, drone_port, drone_init_yaw)

%% Multicopter Parameters
% load in the parameters for a frame, generated by Copter.m
params.mB   = 2.4;      % kg
params.IBxx = 0.0290;   % kg*m^2
params.IByy = 0.0290;   % kg*m^2
params.IBzz = 0.0580;   % kg*m^2

params.g    = 9.80665;
params.rho  = 1.225;

params.dxm  = 0.16;
params.dym  = 0.16;
params.dzm  = 0.05;

params.thrVelCoeff = 0.01;
corrFactor  = 0.8;
params.kTh  = 1.4738e-05 * corrFactor;% N/(rad/s)
params.kTo  = 2.5430e-07;             % N*m/(rad/s)
params.c0   = -75.23;
params.c1   = 26.44;
params.Jm   = 5.5e-5;                 % kg*m^2
params.Res  = 0.120;                  % Ohms
params.L    = 0.0003;                 % Henry
params.kt   = 0.0091;                 % N*m/Amp
params.kv   = 0.0091;                 % Volt/(rad/s)
params.b    = 1.0e-9;                 % N*m/(rad/s)

params.efpa0_tilt =  0.0921351;
params.efpa1_tilt = -0.00434747;
params.efpa2_tilt = -0.0115866;
params.efpa0_vel  =  0.0998675;
params.efpa1_vel  = -8.5301e-04;
params.Area = 0.08;
params.Cd   = 1;

params.wMaxNoload = 2455.7;           % rad/s
params.wMin       = 100;              % rad/s

params.batt_voltage = 6*4.2; % (volts)
params.batt_resistance = 0.0034; % (ohms)

state_drone.params = params;

%% Vehicle Parameters
state_target.max_jerk = 2;       % Maximum Jerk (m/s^3)
state_target.max_acc = 4;      % Maximum Acceleration (m/s^2)

state_target.max_jerk_brk = 1;       % Maximum Jerk (m/s^3)
state_target.max_acc_brk = 1;      % Maximum Acceleration (m/s^2)

state_target.target_vel = 0;       % Initialize Target Velocity (m/s)

state_target.Pv = 1;
state_target.Dv = 0;
state_target.Pa = 2;
state_target.Da = 0;

state_target.min_vel = 5.5555;
state_target.max_vel = 33.3333;

state_target.gravity_mss = state_drone.params.g; % (m/s^2)

%% Simulation Parameters
% Setup the time step size for the Physics model
max_timestep = 1/50;

% define init and time setup functions
init_function_drone = @init_drone;
physics_function_drone = @physics_step_drone;

init_function_target = @init_target;
physics_function_target = @physics_step_target;

% setup connection
double_SITL_connector(state_drone, state_target, ...
                      drone_init_yaw, target_init_yaw, ...
                      init_function_drone, init_function_target, ...
                      physics_function_drone, physics_function_target, ...
                      drone_port, target_port, ...
                      max_timestep);
end

% Simulator model must take and return a structure with the felids: 
% gyro(roll, pitch, yaw) (radians/sec) body frame
% attitude(roll, pitch yaw) (radians)
% accel(north, east, down) (m/s^2) body frame
% velocity(north, east,down) (m/s) earth frame
% position(north, east, down) (m) earth frame 
% the structure can have any other felids required for the physics model

%% Init function for DRONE
function state = init_drone(state, init_yaw)

state.STATE = zeros( 1, 21 );
state.time_s = 0;

% Motor states
state.STATE(5) = 0; % I1
state.STATE(6) = 0; % I2
state.STATE(7) = 0; % I3
state.STATE(8) = 0; % I4

state.STATE(12) = 0; % w1
state.STATE(13) = 0; % w2
state.STATE(14) = 0; % w3
state.STATE(15) = 0; % w4

% Rotation states
state.gyro = [0;0;0]; % (rad/sec)
state.attitude = [0;0;init_yaw*pi/180]; % (radians) (roll, pitch, yaw)
state.quat = YPRToQuat(state.attitude(3), state.attitude(2), state.attitude(1));
state.dcm = quat2Dcm(state.quat);

state.STATE(1) = state.quat(1); % e0
state.STATE(2) = state.quat(2); % e1
state.STATE(3) = state.quat(3); % e2
state.STATE(4) = state.quat(4); % e3

state.STATE(9)  = state.gyro(1); % p
state.STATE(10) = state.gyro(2); % p
state.STATE(11) = state.gyro(3); % p

% Translation states
state.accel = [0;0;0]; % (m/s^2) body frame
state.velocity = [0;0;0]; % (m/s) earth frame (NED)
state.position = [0;0;0]; % (m) earth frame (NED)
state.bf_velo = [0;0;0]; % (m/s) body frame

state.STATE(16) = state.position(1); % x (N)
state.STATE(17) = state.position(2); % y (E)
state.STATE(18) = state.position(3); % z (D)

state.STATE(17) = state.velocity(1); % vx (N)
state.STATE(20) = state.velocity(2); % vy (E)
state.STATE(21) = state.velocity(3); % vz (D)


end

%% Physics time step for DRONE
function state = physics_step_drone(pwm_in,state)

Command = (pwm_in(10:13)-1500)/500*100;

[Sol,Output] = Quad3D_Algebraic(state.time_s, state.params, state.STATE, Command);

% Rotation states
rot_accel = [Sol(4);Sol(5);Sol(6)];

state.gyro = state.gyro + rot_accel * state.delta_t;

state.gyro = max(state.gyro,deg2rad(-2000));
state.gyro = min(state.gyro,deg2rad(2000));

[state.dcm, state.attitude] = rotate_dcm(state.dcm,state.gyro * state.delta_t);
state.quat = YPRToQuat(state.attitude(3), state.attitude(2), state.attitude(1));

state.STATE(1) = state.quat(1); % e0
state.STATE(2) = state.quat(2); % e1
state.STATE(3) = state.quat(3); % e2
state.STATE(4) = state.quat(4); % e3

state.STATE(9)  = state.gyro(1); % p
state.STATE(10) = state.gyro(2); % p
state.STATE(11) = state.gyro(3); % p

% Translation states
accel_ef = [Sol(1);Sol(2);Sol(3)];

ODE_pos = [Output(2);Output(3);Output(4)];

% if we're on the ground, then our vertical acceleration is limited
% to zero. This effectively adds the force of the ground on the aircraft
if  state.position(3) >= 0 && accel_ef(3) > 0
    accel_ef(3) = 0;
end

% work out acceleration as seen by the accelerometers. It sees the kinematic
% acceleration (ie. real movement), plus gravity
state.accel = state.dcm' * (accel_ef + [0; 0; -state.params.g]);

state.velocity = state.velocity + accel_ef * state.delta_t;
state.position = state.position + state.velocity * state.delta_t;

% make sure we can't go underground (NED so underground is positive)
if state.position(3) >= 0
    state.position(3) = 0;
    state.velocity = [0;0;0];
    state.gyro = [0;0;0];
end

state.airspeed = Output(47);

state.STATE(16) = state.position(1); % x (N)
state.STATE(17) = state.position(2); % y (E)
state.STATE(18) = state.position(3); % z (D)

state.STATE(19) = state.velocity(1); % vx (N)
state.STATE(20) = state.velocity(2); % vy (E)
state.STATE(21) = state.velocity(3); % vz (D)

state.STATE(5) = state.STATE(5) + Sol(11)*state.delta_t;
state.STATE(6) = state.STATE(6) + Sol(12)*state.delta_t;
state.STATE(7) = state.STATE(7) + Sol(13)*state.delta_t;
state.STATE(8) = state.STATE(8) + Sol(14)*state.delta_t;

state.STATE(12) = state.STATE(12) + Sol(7)*state.delta_t;
state.STATE(13) = state.STATE(13) + Sol(8)*state.delta_t;
state.STATE(14) = state.STATE(14) + Sol(9)*state.delta_t;
state.STATE(15) = state.STATE(15) + Sol(10)*state.delta_t;

end

%% Init function for TARGET
function state = init_target(state, init_yaw)
state.time_s = 0;
state.gyro = [0;0;0]; % (rad/sec)
% state.dcm = diag([1,1,1]); % direction cosine matrix
state.dcm = [[ cosd(init_yaw), -sind(init_yaw), 0];
             [ sind(init_yaw),  cosd(init_yaw), 0];
             [              0                0  1]];
state.attitude = [0;0;init_yaw*pi/180]; % (radians) (roll, pitch, yaw)
state.accel = [0;0;0]; % (m/s^2) body frame (seen by accelerometers)
state.accel_dyn = [0;0;0]; % (m/s^2) body frame (obtained from F=ma) DOESNT INCLUDE GRAVITY
state.accel_ef = [0;0;0]; % (m/s^2) earth frame
state.velocity = [0;0;0]; % (m/s) earth frame
state.position = [0;0;0]; % (m) earth frame
state.bf_velo = [0;0;0]; % (m/s) body frame
state.jerk_dyn = [0;0;0]; % (m/s^3) body frame
state.startMove = 0;
end

%% Physics time step for TARGET
function state = physics_step_target(pwm_in,state)

if pwm_in(8) >= 1000 && pwm_in(8) <= 2000
    recv_vel_target = (pwm_in(8)-1000)/1000*(state.max_vel-state.min_vel) + state.min_vel;
else
    recv_vel_target = 0;
end

state.target_vel = recv_vel_target;

if all(pwm_in(1:4) > 1050)
    state.startMove = 1;
end

rot_accel = zeros([3,1]);

state.gyro = zeros([3,1]);

% Constrain to 2000 deg per second, this is what typical sensors max out at
state.gyro = max(state.gyro,deg2rad(-2000));
state.gyro = min(state.gyro,deg2rad(2000));

% update the dcm and attitude
[state.dcm, state.attitude] = rotate_dcm(state.dcm,state.gyro * state.delta_t);

if state.startMove == 1
    % Velocity control
    vel_error  = state.target_vel - state.bf_velo(1);
    acc_target = state.Pv*vel_error - state.Dv*state.accel_dyn(1);
    acc_target = max([min([acc_target, state.max_acc]), -state.max_acc_brk]);
    
    % Acceleration control
    acc_error = acc_target - state.accel_dyn(1);
    jerk_target = state.Pa*acc_error - state.Da*state.jerk_dyn(1);
    if acc_target >= 0
        jerk_target = min([jerk_target, state.max_jerk]);
    else
        jerk_target = max([jerk_target, -state.max_jerk_brk]);
    end
    
    % Calculate velocity and position
    state.jerk_dyn  = [jerk_target;0;0];
    state.accel_dyn = state.accel_dyn + state.jerk_dyn*state.delta_t;
else
    state.jerk_dyn  = [0;0;0];
    state.accel_dyn = state.accel_dyn + state.jerk_dyn*state.delta_t;
end

% earth frame accelerations (NED)
accel_ef = state.dcm * state.accel_dyn;
accel_ef(3) = accel_ef(3) + state.gravity_mss;

% if we're on the ground, then our vertical acceleration is limited
% to zero. This effectively adds the force of the ground on the aircraft
if state.position(3) >= 0 && accel_ef(3) > 0
    accel_ef(3) = 0;
end

% work out acceleration as seen by the accelerometers. It sees the kinematic
% acceleration (ie. real movement), plus gravity
state.accel = state.dcm' * (accel_ef + [0; 0; -state.gravity_mss]);

state.velocity = state.velocity + accel_ef * state.delta_t;
state.position = state.position + state.velocity * state.delta_t;

% make sure we can't go underground (NED so underground is positive)
if state.position(3) >= 0
    state.position(3) = 0;
    state.velocity(3) = 0;
end

% calculate the body frame velocity for drag calculation
state.bf_velo = state.dcm' * state.velocity;

end

%% Rotate DCM function
function [dcm, euler] = rotate_dcm(dcm, ang)

% rotate
delta = [dcm(1,2) * ang(3) - dcm(1,3) * ang(2),         dcm(1,3) * ang(1) - dcm(1,1) * ang(3),      dcm(1,1) * ang(2) - dcm(1,2) * ang(1);
         dcm(2,2) * ang(3) - dcm(2,3) * ang(2),         dcm(2,3) * ang(1) - dcm(2,1) * ang(3),      dcm(2,1) * ang(2) - dcm(2,2) * ang(1);
         dcm(3,2) * ang(3) - dcm(3,3) * ang(2),         dcm(3,3) * ang(1) - dcm(3,1) * ang(3),      dcm(3,1) * ang(2) - dcm(3,2) * ang(1)];

dcm = dcm + delta;

% normalise
a = dcm(1,:);
b = dcm(2,:);
error = a * b';
t0 = a - (b *(0.5 * error));
t1 = b - (a *(0.5 * error));
t2 = cross(t0,t1);
dcm(1,:) = t0 * (1/norm(t0));
dcm(2,:) = t1 * (1/norm(t1));
dcm(3,:) = t2 * (1/norm(t2));

% calculate euler angles
euler = [atan2(dcm(3,2),dcm(3,3)); -asin(dcm(3,1)); atan2(dcm(2,1),dcm(1,1))]; 

end

